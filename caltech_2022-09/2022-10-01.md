# Docker Compose vs Docker Swarm vs Kubernetes
1. Docker Compose is a Python script that works as wrapper of Docker commands:
    ```
    which docker-compose

    file /usr/bin/docker-compose 

    head /usr/bin/docker-compose
    ```
1. Docker Compose does not provide high availability because it is only available as a standalone host machine. If we need high availability then we need to use Docker Swarm or Kubernetes. Docker Swarm is a feature of the Docker engine that is enabled with the following commands:

    * https://labs.play-with-docker.com/

    ```
    docker swarm init --advertise-addr $( hostname -i )
    ```
1. Check the status of the cluster with the command:

    ```
    docker node ls
    ```
1. Architecture of managers and workers:

    * https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg
1. Create a Docker Compose file for this cluster using Docker Swarm (Docker Compose version 3):

    * https://docs.docker.com/compose/compose-file/compose-file-v3/

    ```
    tee ${PWD}/docker-swarm.yaml 0<<EOF

    # docker run --detach --name phpinfo --network phpinfo-default --restart always --publish 8080 --user nobody:nogroup --volume ${PWD}/index.php:/data/index.php:ro --workdir /data/ index.docker.io/library/php:alpine php -f index.php -S 0.0.0.0:8080
    configs:
      phpinfo-config:
        external: false
        file: index.php
    services:
      phpinfo:
        # command: [ "php","-f","index.php","-S","0.0.0.0:8080" ]
        command:
          - php
          - -f
          - index.php
          - -S
          - 0.0.0.0:8080
        configs:
          - source: phpinfo-config
            target: /data/index.php
            uid: '65534'
            gid: '65534'
            mode: 0400
        deploy:
          placement:
            constraints:
              - "node.role==worker"      
          replicas: 1
        image: index.docker.io/library/php:alpine
        ports:
          - 8080
        user: nobody:nogroup
        working_dir: /data/
    version: '3.8'

    EOF
    ```
1. Now download the index.php artifact:

    ```
    wget https://raw.githubusercontent.com/academiaonline-org/phpinfo/main/src/index.php
    ```
1. Deploy the application with the following command:

    ```
    docker stack deploy --compose-file docker-swarm.yaml PHPINFO
    ```
1. From our configuration, the entrypoint is not PHP binary. We can get the entrypoint with the following commands:

    ```
    $ docker ps --no-trunc
    CONTAINER ID                                                       IMAGE                                                                                COMMAND                                                    CREATED          STATUS          PORTS     NAMESa8990edbd5f334b6836052b80b1cb2896dd1e1e9ade455bb924dab2025126446   php:alpine@sha256:8605eae8361d45f6ca66205fac0b633da2c01d2771d9fc1a1e
    5013dfb7646834   "docker-php-entrypoint php -f index.php -S 0.0.0.0:8080"   13 minutes ago   Up 13 minutes             PHPINFO_phpinfo.
    1.mq2wnj25if9dw394mpv9k5gbo
    ```
    ```
    $ docker exec PHPINFO_phpinfo.1.mq2wnj25if9dw394mpv9k5gbo which docker-php-entrypoint
    /usr/local/bin/docker-php-entrypoint
    ```
    ```
    $ docker exec PHPINFO_phpinfo.1.mq2wnj25if9dw394mpv9k5gbo cat /usr/local/bin/docker-php-entrypoint
    #!/bin/sh
    set -e

    # first arg is `-f` or `--some-option`
    if [ "${1#-}" != "$1" ]; then
            set -- php "$@"
    fi

    exec "$@"
    ```
1. You can temporarily drain the worker node:
    ```
    docker node update --availability drain node2
    ```
1. The result is the application deployment will be in a pending state:

    ```
    $ docker stack ps PHPINFO 
    ID             NAME                    IMAGE        NODE      DESIRED STATE   CURRENT STATE           ERROR                            
      PORTS
    8rrr8ske9cu5   PHPINFO_phpinfo.1       php:alpine             Ready           Pending 9 seconds ago   "no suitable node (1 node not â€¦" 

    mq2wnj25if9d    \_ PHPINFO_phpinfo.1   php:alpine   node2     Shutdown        Running 9 seconds ago                                    
    ```  
1. To solve this situation we need High Availability. For that purpose we can add another node to the cluste with the following command:

    ```
    docker swarm join-token worker
    ```
1. Now you can check that the second worker node has been added to the cluster:

    ```
    $ docker node ls
    ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
    1klh30n51s1k7mzbopwccrqjx *   node1      Ready     Active         Leader           20.10.17
    p2kzgypwh7ee65n7bgodqqjf4     node2      Ready     Drain                           20.10.17
    vyqrh9s5ircth2amyeke8cmf1     node3      Ready     Active                          20.10.17
    ```
1. You can check that the application has been correctly deployed on the new worker node:

    ```
    $ docker stack ps PHPINFO 
    ID             NAME                    IMAGE        NODE      DESIRED STATE   CURRENT STATE                ERROR     PORTS
    8rrr8ske9cu5   PHPINFO_phpinfo.1       php:alpine   node3     Running         Running about a minute ago             
    mq2wnj25if9d    \_ PHPINFO_phpinfo.1   php:alpine   node2     Shutdown        Shutdown 7 minutes ago  
    ```
1. We can add more managers to the cluster:

    ```
    docker swarm join-token manager
    ```
1. We can scale up or down the application modifying the number of replicas in the Docker Compose manifest or with the following command:

    ```
    docker service scale PHPINFO_phpinfo=10
    ```
1. You can open a terminal inside the container for troubleshooting purposes with the following command:

    ```
    docker exec --interactive --tty PHPINFO_phpinfo.1.475n41g0f8cz99xlzhzcuee8v sh
    ```
    
3. In order to deploy the same application on a Kubernetes cluster we will need a list of independent Kubernetes manifests to create a list of independent Kubernetes objects. Instead of having a single Docker Compose manifest, we will have a collection of manifests to create the necessary Kubernets objects: Config Map, Service and Pod:

```
apiVersion: v1
kind: ConfigMap
metadata:
  name: phpinfo-cm
data:
  index.php: <?php phpinfo();?>
```  
```
apiVersion: v1
kind: Service
metadata:
  name: phpinfo-svc
spec:
  ports:
  - port: 8080
    protocol: TCP
  selector:
    app: phpinfo-po
```  
```
apiVersion: v1
kind: Pod
metadata:
  name: phpinfo-po
  labels:
    app: phpinfo-po
spec:
  containers:
  - args:
    - php
    - -f
    - index.php
    - -S
    - 0.0.0.0:8080
    env:
    - name: OWNER
      value: Sebastian
    image: index.docker.io/library/php:alpine@sha256:6340f86b1dc4325d09cd8311d8c40e36ab54061d0d25ea1491c100578bc50ae1
    name: phpinfo-container
    resources:
      limits:
        cpu: 200m
        memory: 200M
      requests:
        cpu: 200m
        memory: 200M
    securityContext:
      readOnlyRootFilesystem: true
      runAsGroup: 65534
      runAsUser: 65534
    volumeMounts:
    - mountPath: /data/index.php
      name: phpinfo-volume
      readOnly: true
      subPath: index.php
    workingDir: /data/
  volumes:
  - name: phpinfo-volume
    configMap:
      defaultMode: 0400
      items:
      - key: index.php
        mode: 0400
        path: index.php
      name: phpinfo-cm
```          
1. In this link you will find the Reference for the Kubernetes API syntax:

    * https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/
